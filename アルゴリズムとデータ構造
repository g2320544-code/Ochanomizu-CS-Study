アルゴリズムとデータ構造
クイックソート　！！計算量の計算のところ
void sort (int left, int right) { 
int i, j, pivot; 
if (left < right) { 
pivot = table[(left + right) / 2].key;  適当な基準値(ピボット)を選ぶ     
i = left; j = right; 
while (i <= j) { この行から始まるwhile文では、i++かj--が少なくともどちらかは実行されて、整列範囲が狭まるので、i<=jを満たさなくなり、必ず停止
while (table[i].key < pivot) { i++; } pivot が番兵になっていて、必ず停止
while (table[j].key > pivot) { j--; } pivot が番兵になっているので、必ず停止
if (i <= j) { swap (i, j); i++; j--; }  基準値以下の要素を配列の左側に、基準値以上の要素を配列の右側に移す(等しいものはどちらでも良い)
}
sort (left, j); sort (i, right); 配列の左側、右側をそれぞれ整列する再帰、i++とj--がsortの呼び出し中、どちらも必ず１度は実行され、整列範囲が狭まるので、いずれleft < rightを満たさなくなり、必ず停止       
}  
}
平均して O(n log n) 　（n 大なら log n < n0.25） 
• 最悪は O(n2)。これが欠点だがたいていうまくいく。
基準値の選び方
• なるべく中央の値にしたい。 
• 配列の最初や最後は感心しない。 
• ３つの中央値ぐらいで十分。 
• 配列中に出てこない値でもＯＫ。 
• ただし、最小値と最大値の間でないとだめ
計算量はi++ と j-- の実行回数を数える。 
• 長さ n のクイックソートでの実行回数を Qn とおく。 
Qn = n + Qa + Qb 
　ここで a + b = n。 
　（n 個の要素が a 個と b 個に分割されたとする。
計算量（最悪）
Qn = n+Q1+Qn−1
 = n+(n−1)+Q1+Qn−2
 = ⋯
 = n+(n−1)+⋯+2+Q1+Q1
 = n(n+1)
 2 −1
クイックソート 
O(n2)
 =0
絶対に O(n2) かかってはまずい場合には使えない。 
しかし、ほとんどの場合、とても速い

線形探索
配列を前から順に探す。 
int search (int target) { 
  int pos = 0; 
  while (pos < n &&　target != table[pos].key) { pos++; } nは定数でposの値はwhile文の中身を実行するたびに必ず1増えるから、いずれpos≧nになり停止（目的のデータが見つかったらもっと早く停止）
 if (pos < n) { return (pos); } 
else { return (NOT_FOUND); }
 }
アルゴリズムの正当性
• 正しい答えを返すか？ 
全てのデータを前から順に見ているので、いずれ見つかる  
int search (int target) { 
  int pos = 0;  t1
  while (pos < n && target != table[pos].key(t2)) { pos++; (t3)}  
search の while 文の中で毎回 pos < n を判定するのは時間がかかる。代わりに table[n] に target を入れておく（番兵）。
もともと target が table 中に見つからなかったとしても番兵のところで見つかって停止性が保たれる。 計算量はO(n)のままだが、ループ１回あたりの仕事が減って速くなる。
pos < nをable[n].key = target;にする
  if (pos < n) { return (pos); } 
  else { return (NOT_FOUND); } 上と2行でt4
} 
最も速いと 
t = t1 +t2 +t4
最も遅いと
t = t1 +(t2 +t3)n +t2 +t4 = (t2 +t3)n +t1 +t2 +t4
　→ n に比例した時間がかかるO(n)
データの追加と削除
追加：新しいデータを最後に付け加えれば良い (insert_end) 
削除：削除するデータを最後のデータで上書きすれば良い 
　　　(delete) 
いずれも定数時間O(1)ですむ。（削除するデータを探す必要
があるなら、その探索にはO(n)かかる。）

２分探索
• 線形探索ではデータはばらばらに並んでいた。 
　（データに何の構造もなかった。） 
• ２分探索ではデータをあらかじめ（例えば小さい）順に並べておく。 
(端から順に探すのではなく）データの中央を見て、それとの大小によって探索範囲を半分にしていく。
int search (int target) { 
  int lo = 0, hi = n - 1; 
  while (lo <= hi) { 
    mid = (lo + hi) / 2; 
    if (target <= table[mid].key) { hi = mid - 1; } 
    if (target >= table[mid].key) { lo = mid + 1; } 
  } 
  if (lo == hi + 2) { return (lo - 1); } 
  else { return (NOT_FOUND); } 
}
いずれの場合も、target が見つかったら lo と hi がひっくり返って止まる。 
target が見つからないときは hi が真に減るか lo が真に増えている。したがっていずれ hi < lo になり止まる。
正当性
lo <= hi の間は、 
• 目的のデータは lo ～ hi の間に存在する、か 
• 目的のデータは table 中には存在しない 
のどちらかが成り立ち続ける。 
• 前者の場合は、探索範囲が狭まり、いずれ見つかる。 
• 後者の場合も、探索範囲が狭まり、いずれ lo == hi + 
1 になって止まる。
データの追加と削除
追加：データを正しい位置に挿入して残りをずらさなくてはならない（データは順に並んでいないといけないので)
削除：削除後、残りのデータをずらさなくてはならない
どちらも O(n)かかる。 
 木を使うとO(logn)でできるようになる


divide and conquer
分割統治法を使う … 典型的には再帰で実現する。 
① 問題を分割する。 
② 各部分問題を解く。 
③ 部分問題の解から全体の解を作る。

 正当性：正しい答えを返すか？ 停止性：止まるか？ 計算量：効率はどのくらいか？
