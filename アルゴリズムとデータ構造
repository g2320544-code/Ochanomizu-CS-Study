アルゴリズムとデータ構造
クイックソート
プログラム
void sort (int left, int right) { 
int i, j, pivot; 
if (left < right) { 
pivot = table[(left + right) / 2].key;  適当な基準値(ピボット)を選ぶ     
i = left; j = right; 
while (i <= j) { この行から始まるwhile文では、i++かj--が少なくともどちらかは実行されて、整列範囲が狭まるので、i<=jを満たさなくなり、必ず停止
while (table[i].key < pivot) { i++; } pivot が番兵になっていて、必ず停止
while (table[j].key > pivot) { j--; } pivot が番兵になっているので、必ず停止
if (i <= j) { swap (i, j); i++; j--; }  基準値以下の要素を配列の左側に、基準値以上の要素を配列の右側に移す(等しいものはどちらでも良い)
}
sort (left, j); sort (i, right); 配列の左側、右側をそれぞれ整列する再帰、i++とj--がsortの呼び出し中、どちらも必ず１度は実行され、整列範囲が狭まるので、いずれleft < rightを満たさなくなり、必ず停止       
}  
}
平均して O(n log n) 　（n 大なら log n < n0.25） 
• 最悪は O(n2)。これが欠点だがたいていうまくいく。
基準値の選び方
• なるべく中央の値にしたい。 
• 配列の最初や最後は感心しない。 
• ３つの中央値ぐらいで十分。 
• 配列中に出てこない値でもＯＫ。 
• ただし、最小値と最大値の間でないとだめ
計算量はi++ と j-- の実行回数を数える。 
• 長さ n のクイックソートでの実行回数を Qn とおく。 
Qn = n + Qa + Qb 
　ここで a + b = n。 
　（n 個の要素が a 個と b 個に分割されたとする。
計算量（最悪）
Qn = n+Q1+Qn−1
 = n+(n−1)+Q1+Qn−2
 = ⋯
 = n+(n−1)+⋯+2+Q1+Q1
 = n(n+1)
 2 −1
クイックソート 
O(n2)
 =0
絶対に O(n2) かかってはまずい場合には使えない。 
しかし、ほとんどの場合、とても速い

divide and conquer
分割統治法を使う … 典型的には再帰で実現する。 
① 問題を分割する。 
② 各部分問題を解く。 
③ 部分問題の解から全体の解を作る。

 正当性：正しい答えを返すか？ 
• 停止性：止まるか？ 
• 計算量：効率はどのくらいか？
